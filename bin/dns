#!/usr/bin/env node

var exec = require('child_process').exec,
    Linode = require('linode-api').LinodeClient,
    config = require('../config'),
    client = new Linode(config.linode.apiKey),
    _ = require('underscore'),
    async = require('async'),
    program = require('commander'),
    app = require('../package.json'),
    noop = function() {};

var jitsu = {
  balancers: function(domain, cb) {
    exec('host ' + domain, function(error, stdout, stderr) {
      cb(error, stdout.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/g));
    });
  }
};

var linode = {
  getDomainByName: function(name, cb) {
    client.call('domain.list', {}, function (err, res) {
      var domainByName = _.find(res, function(domain) {
        return domain.DOMAIN === name;
      });
      cb(err, domainByName);
    });
  },
  deleteResources: function(resources, cb) {
    async.concat(resources, linode.deleteResource, cb);
  },
  deleteResource: function(resource, cb) {
    client.call('domain.resource.delete', _.pick(resource, 'DOMAINID', 'RESOURCEID'), function(err, res) {
      cb(err, res);
    });
  },
  getResources: function(domainId, filter, cb) {
    client.call('domain.resource.list', {DomainID: domainId}, function(err, res) {
      cb(err, _.filter(res, function(resource) {
        if (typeof filter !== 'function') return true;
        return filter(resource);
      }));
    });
  },
  getEmptyOrWwwResources: function(domain, cb) {
    linode.getResources(domain.DOMAINID || domain, function(resource) {
      return !!(resource.NAME === '' || resource.NAME.toString().toLowerCase() === 'www');
    }, cb);
  },
  createARecord: function(newRecordOpts, cb) {
    linode.getDomainByName(app.name, function(err, domain) {
      client.call('domain.resource.create', _.extend({Type: 'A', DomainID: domain.DOMAINID}, newRecordOpts), function(err, res) {
        cb(err, res);
      });
    });
  },
  createARecordsPerIP: function(ip, cb) {
    var recordOpts = {Name: 'www', Target: ip};
    async.concat([_.extend(_.clone(recordOpts), {Name: ''}), recordOpts], linode.createARecord, cb);
  },
  getIP: function(cb) {
    client.call('linode.list', {}, function(err, result) {
      if (err) cb(err, null);
      client.call('linode.ip.list', {LinodeID: result[0].LINODEID}, function(err, result) {
        cb(err, result[0].IPADDRESS);
      });
    });
  }
};

var dns = {
  addYear: function(year) {
    async.waterfall([
      linode.getIP,
      function(ip, cb) {
        linode.createARecord({Name: year, Target: ip}, cb);
      }
    ],
    function(err, res) {
      if (err) throw err;
    });
  },
  resetFor: function(server) {
    var getIP = null,
        addRecords = null;

    if (server === 'jitsu') {
      getIP = function(res, cb) {
        jitsu.balancers(app.subdomain + '.jit.su', cb);
      };
      addRecords = function(result) {
        async.concat(result, linode.createARecordsPerIP, noop);
      };
    } else if (server === 'static') {
      getIP = function(res, cb) {
        linode.getIP(cb);
      };
      addRecords = function(result) {
        linode.createARecordsPerIP(result, noop);
      };
    }

    if (!getIP || !addRecords) return;

    async.waterfall([
      function(cb) {
        linode.getDomainByName(app.name, cb);
      },
      linode.getEmptyOrWwwResources,
      linode.deleteResources,
      getIP
    ],
    function(err, result) {
      if (err) throw err;
      addRecords(result);
    });
  }
};

program
  .option('-y, --year <year>', 'add Linode dns entry for <year>', parseInt)
  .option('-r, --reset <server>', 'reset Linode dns entries for <server>')
  .parse(process.argv);

if (program.year) dns.addYear(program.year);
if (program.reset) dns.resetFor(program.reset);
